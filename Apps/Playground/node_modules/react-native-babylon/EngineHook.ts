import { useState, useEffect } from 'react';
import { Engine, NativeEngine } from '@babylonjs/core';
import { BabylonModule } from './BabylonModule';

// TEMP HACK: Engine.dispose assumes that if window exists, then document does too, which is not the case in react native. Declare window so we can use it to define a global document object.
declare const window: any;

export async function useEngine(engineCallback: (engine: Engine) => void) {
    const [engine, setEngine] = useState<Engine>();

    useEffect(() => {
        if (engine) {
            console.log("--- CALLING ENGINE CALLBACK ---");
            engineCallback(engine);

            return () => {
                console.log("--- DISPOSING ENGINE ---");
                // TEMP HACK: Engine.dispose assumes that if window exists, then document does too, which is not the case in react native. Temporarily stub it out before disposing until this gets fixed in Babylon.js.
                window["document"] = { removeEventListener: (eventName: any, eventHandler: any) => {} };
                engine.dispose();
                window["document"] = undefined;
            };
        }
    }, [engine]);

    useEffect(() => {
        (async () => {
            console.log("--- AWAITING INITIALIZATION ---");
            await BabylonModule.initializeEngine();

             // TEMP HACK: Override this because Babylon Native uses the presence of window.requestAnimationFrame to decide whether to run the native or JS code path, but React Native polyfills window.requestAnimationFrame.
            (NativeEngine.prototype as any)._queueNewFrame = function (bindedRenderFunction: any, requester: any) {
                this._native.requestAnimationFrame(bindedRenderFunction);
                return 0;
            };
            setEngine(new NativeEngine());
        })();
    }, []);
}