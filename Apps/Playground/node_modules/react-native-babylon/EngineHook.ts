import { useState, useEffect } from 'react';
import { Engine, NativeEngine } from '@babylonjs/core';
import { BabylonModule } from './BabylonModule';
import { DisposeEngine, IsEngineDisposed } from './EngineHelpers';

var engineUid = 0;

export async function useEngine(engineCallback: (engine: Engine) => void) {
    const [engine, setEngine] = useState<Engine>();

    useEffect(() => {
        if (engine && !IsEngineDisposed(engine)) {
            console.log("--- CALLING ENGINE CALLBACK ---: " + (engine as any)["uid"]);
            engineCallback(engine);

            return () => {
                console.log("--- DISPOSING ENGINE ---: " + (engine as any)["uid"]);
                DisposeEngine(engine);
            };
        }
    }, [engine]);

    useEffect(() => {
        (async () => {
            console.log("--- AWAITING INITIALIZATION ---");
            if (await BabylonModule.initialize())
            {
                // TEMP HACK: Override this because Babylon Native uses the presence of window.requestAnimationFrame to decide whether to run the native or JS code path, but React Native polyfills window.requestAnimationFrame.
                (NativeEngine.prototype as any)._queueNewFrame = function (bindedRenderFunction: any, requester: any) {
                    this._native.requestAnimationFrame(bindedRenderFunction);
                    return 0;
                };
                const newEngine = new NativeEngine();
                (newEngine as any)["uid"] = engineUid++;
                console.log("--- INSTANTIATED ENGINE ---: " + (newEngine as any)["uid"]);
                setEngine(newEngine);
            }
        })();
    }, []);
}