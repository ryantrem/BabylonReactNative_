import React, { FunctionComponent, Component, useEffect, useState } from 'react';
import {requireNativeComponent, ViewProps, NativeSyntheticEvent} from 'react-native';
import { Engine, NativeEngine } from '@babylonjs/core';

interface NativeEngineViewProps extends ViewProps {
    viewReady: (e: NativeSyntheticEvent<void>) => void;
}

const NativeEngineView: {
    prototype: Component<NativeEngineViewProps>;
    new(props: Readonly<NativeEngineViewProps>): Component<NativeEngineViewProps>;
} = requireNativeComponent('EngineView');

export interface EngineViewProps extends ViewProps {
    onViewReady: (engine: Engine) => void;
}

// TEMP HACK: Engine.dispose assumes that if window exists, then document does too, which is not the case in react native. Declare window so we can use it to define a global document object.
declare const window: any;

export const EngineView: FunctionComponent<EngineViewProps> = (props: EngineViewProps) => {

    const [nativeEngine, setNativeEngine] = useState<NativeEngine>();

    useEffect(() => {
        if (nativeEngine) {
            nativeEngine.runRenderLoop(function () {
                for (let scene of nativeEngine.scenes) {
                    scene.render();
                }
            });

            return () => {
                // TEMP HACK: Engine.dispose assumes that if window exists, then document does too, which is not the case in react native. Temporarily stub it out before disposing until this gets fixed in Babylon.js.
                window["document"] = {
                    removeEventListener: (eventName: any, eventHandler: any) => {},
                };
                nativeEngine.dispose();
                window["document"] = undefined;
            };
        }
    }, [nativeEngine]);

    const onViewReady = (e: NativeSyntheticEvent<void>) => {
        // TEMP HACK: Override this because Babylon Native uses the presence of window.requestAnimationFrame to decide whether to run the native or JS code path, but React Native polyfills window.requestAnimationFrame.
        (NativeEngine.prototype as any)._queueNewFrame = function (bindedRenderFunction: any, requester: any) {
            this._native.requestAnimationFrame(bindedRenderFunction);
            return 0;
        };

        var nativeEngine = new NativeEngine();
        setNativeEngine(nativeEngine);
        props.onViewReady(nativeEngine);
    };

    return (
        <NativeEngineView style={props.style} viewReady={onViewReady} />
    );
}