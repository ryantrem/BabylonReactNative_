import React, { FunctionComponent, Component, useEffect, useState } from 'react';
import {requireNativeComponent, ViewProps, NativeSyntheticEvent} from 'react-native';
import { Engine, NativeEngine } from '@babylonjs/core';

interface NativeEngineViewProps extends ViewProps {
    viewReady: (e: NativeSyntheticEvent<void>) => void;
}

const NativeEngineView: {
    prototype: Component<NativeEngineViewProps>;
    new(props: Readonly<NativeEngineViewProps>): Component<NativeEngineViewProps>;
} = requireNativeComponent('EngineView');

export interface EngineViewProps extends ViewProps {
    onViewReady: (engine: Engine) => void;
}

export const EngineView: FunctionComponent<EngineViewProps> = (props: EngineViewProps) => {

    const [nativeEngine, setNativeEngine] = useState<NativeEngine>();

    useEffect(() => {
        if (nativeEngine) {
            nativeEngine.runRenderLoop(function () {
                for (let scene of nativeEngine.scenes) {
                    scene.render();
                }
            });

            return () => {
                nativeEngine.dispose();
            };
        }
    }, [nativeEngine]);

    const onViewReady = (e: NativeSyntheticEvent<void>) => {
        // TEMP HACK: Override this because Babylon Native uses the presence of window.requestAnimationFrame to decide whether to run the native or JS code path, but React Native polyfills window.requestAnimationFrame.
        (NativeEngine.prototype as any)._queueNewFrame = function (bindedRenderFunction: any, requester: any) {
            this._native.requestAnimationFrame(bindedRenderFunction);
            return 0;
        };

        var nativeEngine = new NativeEngine();
        setNativeEngine(nativeEngine);
        props.onViewReady(nativeEngine);
    };

    return (
        <NativeEngineView style={props.style} viewReady={onViewReady} />
    );
}